package ofxgo

/*
 * Do not edit this file by hand. It is auto-generated by calling `go generate`.
 * To make changes, edit generate_constants.py, re-run `go generate`, and check
 * in the result.
 */

import (
	"errors"
	"fmt"
	"strings"

	"github.com/aclindsa/xml"
)

type ofxVersion uint

// OfxVersion* constants represent the OFX specification version in use
const (
	OfxVersion102 ofxVersion = 1 + iota
	OfxVersion103
	OfxVersion151
	OfxVersion160
	OfxVersion200
	OfxVersion201
	OfxVersion202
	OfxVersion203
	OfxVersion210
	OfxVersion211
	OfxVersion220
)

var ofxVersions = [...]string{"102", "103", "151", "160", "200", "201", "202", "203", "210", "211", "220"}

func (e ofxVersion) Valid() bool {
	// This check is mostly out of paranoia, ensuring e != 0 should be
	// sufficient
	return e >= OfxVersion102 && e <= OfxVersion220
}

func (e ofxVersion) String() string {
	if e.Valid() {
		return ofxVersions[e-1]
	}
	return fmt.Sprintf("invalid ofxVersion (%d)", e)
}

func (e *ofxVersion) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range ofxVersions {
		if s == value {
			*e = ofxVersion(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid OfxVersion: \"" + in + "\"")
}

func (e *ofxVersion) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *ofxVersion) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if !e.Valid() {
		return nil
	}
	enc.EncodeElement(ofxVersions[*e-1], start)
	return nil
}

// NewOfxVersion returns returns an 'enum' value of type ofxVersion given its
// string representation
func NewOfxVersion(s string) (ofxVersion, error) {
	var e ofxVersion
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type acctType uint

// AcctType* constants represent types of bank accounts
const (
	AcctTypeChecking acctType = 1 + iota
	AcctTypeSavings
	AcctTypeMoneyMrkt
	AcctTypeCreditLine
	AcctTypeCD
)

var acctTypes = [...]string{"CHECKING", "SAVINGS", "MONEYMRKT", "CREDITLINE", "CD"}

func (e acctType) Valid() bool {
	// This check is mostly out of paranoia, ensuring e != 0 should be
	// sufficient
	return e >= AcctTypeChecking && e <= AcctTypeCD
}

func (e acctType) String() string {
	if e.Valid() {
		return acctTypes[e-1]
	}
	return fmt.Sprintf("invalid acctType (%d)", e)
}

func (e *acctType) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range acctTypes {
		if s == value {
			*e = acctType(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid AcctType: \"" + in + "\"")
}

func (e *acctType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *acctType) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if !e.Valid() {
		return nil
	}
	enc.EncodeElement(acctTypes[*e-1], start)
	return nil
}

// NewAcctType returns returns an 'enum' value of type acctType given its
// string representation
func NewAcctType(s string) (acctType, error) {
	var e acctType
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type trnType uint

// TrnType* constants represent types of transactions. INT, ATM, and POS depend on the signage of the account.
const (
	TrnTypeCredit trnType = 1 + iota
	TrnTypeDebit
	TrnTypeInt
	TrnTypeDiv
	TrnTypeFee
	TrnTypeSrvChg
	TrnTypeDep
	TrnTypeATM
	TrnTypePOS
	TrnTypeXfer
	TrnTypeCheck
	TrnTypePayment
	TrnTypeCash
	TrnTypeDirectDep
	TrnTypeDirectDebit
	TrnTypeRepeatPmt
	TrnTypeHold
	TrnTypeOther
)

var trnTypes = [...]string{"CREDIT", "DEBIT", "INT", "DIV", "FEE", "SRVCHG", "DEP", "ATM", "POS", "XFER", "CHECK", "PAYMENT", "CASH", "DIRECTDEP", "DIRECTDEBIT", "REPEATPMT", "HOLD", "OTHER"}

func (e trnType) Valid() bool {
	// This check is mostly out of paranoia, ensuring e != 0 should be
	// sufficient
	return e >= TrnTypeCredit && e <= TrnTypeOther
}

func (e trnType) String() string {
	if e.Valid() {
		return trnTypes[e-1]
	}
	return fmt.Sprintf("invalid trnType (%d)", e)
}

func (e *trnType) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range trnTypes {
		if s == value {
			*e = trnType(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid TrnType: \"" + in + "\"")
}

func (e *trnType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *trnType) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if !e.Valid() {
		return nil
	}
	enc.EncodeElement(trnTypes[*e-1], start)
	return nil
}

// NewTrnType returns returns an 'enum' value of type trnType given its
// string representation
func NewTrnType(s string) (trnType, error) {
	var e trnType
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type imageType uint

// ImageType* constants represent what this image contains
const (
	ImageTypeStatement imageType = 1 + iota
	ImageTypeTransaction
	ImageTypeTax
)

var imageTypes = [...]string{"STATEMENT", "TRANSACTION", "TAX"}

func (e imageType) Valid() bool {
	// This check is mostly out of paranoia, ensuring e != 0 should be
	// sufficient
	return e >= ImageTypeStatement && e <= ImageTypeTax
}

func (e imageType) String() string {
	if e.Valid() {
		return imageTypes[e-1]
	}
	return fmt.Sprintf("invalid imageType (%d)", e)
}

func (e *imageType) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range imageTypes {
		if s == value {
			*e = imageType(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid ImageType: \"" + in + "\"")
}

func (e *imageType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *imageType) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if !e.Valid() {
		return nil
	}
	enc.EncodeElement(imageTypes[*e-1], start)
	return nil
}

// NewImageType returns returns an 'enum' value of type imageType given its
// string representation
func NewImageType(s string) (imageType, error) {
	var e imageType
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type imageRefType uint

// ImageRefType* constants represent the type of reference to the image
const (
	ImageRefTypeOpaque imageRefType = 1 + iota
	ImageRefTypeURL
	ImageRefTypeFormURL
)

var imageRefTypes = [...]string{"OPAQUE", "URL", "FORMURL"}

func (e imageRefType) Valid() bool {
	// This check is mostly out of paranoia, ensuring e != 0 should be
	// sufficient
	return e >= ImageRefTypeOpaque && e <= ImageRefTypeFormURL
}

func (e imageRefType) String() string {
	if e.Valid() {
		return imageRefTypes[e-1]
	}
	return fmt.Sprintf("invalid imageRefType (%d)", e)
}

func (e *imageRefType) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range imageRefTypes {
		if s == value {
			*e = imageRefType(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid ImageRefType: \"" + in + "\"")
}

func (e *imageRefType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *imageRefType) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if !e.Valid() {
		return nil
	}
	enc.EncodeElement(imageRefTypes[*e-1], start)
	return nil
}

// NewImageRefType returns returns an 'enum' value of type imageRefType given its
// string representation
func NewImageRefType(s string) (imageRefType, error) {
	var e imageRefType
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type checkSup uint

// CheckSup* constants represent what portions of the check this image contains
const (
	CheckSupFrontOnly checkSup = 1 + iota
	CheckSupBackOnly
	CheckSupFrontAndBack
)

var checkSups = [...]string{"FRONTONLY", "BACKONLY", "FRONTANDBACK"}

func (e checkSup) Valid() bool {
	// This check is mostly out of paranoia, ensuring e != 0 should be
	// sufficient
	return e >= CheckSupFrontOnly && e <= CheckSupFrontAndBack
}

func (e checkSup) String() string {
	if e.Valid() {
		return checkSups[e-1]
	}
	return fmt.Sprintf("invalid checkSup (%d)", e)
}

func (e *checkSup) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range checkSups {
		if s == value {
			*e = checkSup(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid CheckSup: \"" + in + "\"")
}

func (e *checkSup) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *checkSup) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if !e.Valid() {
		return nil
	}
	enc.EncodeElement(checkSups[*e-1], start)
	return nil
}

// NewCheckSup returns returns an 'enum' value of type checkSup given its
// string representation
func NewCheckSup(s string) (checkSup, error) {
	var e checkSup
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type correctAction uint

// CorrectAction* constants represent whether this transaction correction replaces or deletes the transaction matching its CORRECTFITID
const (
	CorrectActionDelete correctAction = 1 + iota
	CorrectActionReplace
)

var correctActions = [...]string{"DELETE", "REPLACE"}

func (e correctAction) Valid() bool {
	// This check is mostly out of paranoia, ensuring e != 0 should be
	// sufficient
	return e >= CorrectActionDelete && e <= CorrectActionReplace
}

func (e correctAction) String() string {
	if e.Valid() {
		return correctActions[e-1]
	}
	return fmt.Sprintf("invalid correctAction (%d)", e)
}

func (e *correctAction) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range correctActions {
		if s == value {
			*e = correctAction(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid CorrectAction: \"" + in + "\"")
}

func (e *correctAction) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *correctAction) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if !e.Valid() {
		return nil
	}
	enc.EncodeElement(correctActions[*e-1], start)
	return nil
}

// NewCorrectAction returns returns an 'enum' value of type correctAction given its
// string representation
func NewCorrectAction(s string) (correctAction, error) {
	var e correctAction
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type balType uint

// BalType* constants represent how this BAL's VALUE field should be interpreted
const (
	BalTypeDollar balType = 1 + iota
	BalTypePercent
	BalTypeNumber
)

var balTypes = [...]string{"DOLLAR", "PERCENT", "NUMBER"}

func (e balType) Valid() bool {
	// This check is mostly out of paranoia, ensuring e != 0 should be
	// sufficient
	return e >= BalTypeDollar && e <= BalTypeNumber
}

func (e balType) String() string {
	if e.Valid() {
		return balTypes[e-1]
	}
	return fmt.Sprintf("invalid balType (%d)", e)
}

func (e *balType) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range balTypes {
		if s == value {
			*e = balType(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid BalType: \"" + in + "\"")
}

func (e *balType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *balType) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if !e.Valid() {
		return nil
	}
	enc.EncodeElement(balTypes[*e-1], start)
	return nil
}

// NewBalType returns returns an 'enum' value of type balType given its
// string representation
func NewBalType(s string) (balType, error) {
	var e balType
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type inv401kSource uint

// Inv401kSource* constants represent the source of money used for this security in a 401(k) account. Default if not present is OTHERNONVEST. The following cash source types are subject to vesting: MATCH, PROFITSHARING, and OTHERVEST.
const (
	Inv401kSourcePreTax inv401kSource = 1 + iota
	Inv401kSourceAfterTax
	Inv401kSourceMatch
	Inv401kSourceProfitSharing
	Inv401kSourceRollover
	Inv401kSourceOtherVest
	Inv401kSourceOtherNonVest
)

var inv401kSources = [...]string{"PRETAX", "AFTERTAX", "MATCH", "PROFITSHARING", "ROLLOVER", "OTHERVEST", "OTHERNONVEST"}

func (e inv401kSource) Valid() bool {
	// This check is mostly out of paranoia, ensuring e != 0 should be
	// sufficient
	return e >= Inv401kSourcePreTax && e <= Inv401kSourceOtherNonVest
}

func (e inv401kSource) String() string {
	if e.Valid() {
		return inv401kSources[e-1]
	}
	return fmt.Sprintf("invalid inv401kSource (%d)", e)
}

func (e *inv401kSource) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range inv401kSources {
		if s == value {
			*e = inv401kSource(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid Inv401kSource: \"" + in + "\"")
}

func (e *inv401kSource) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *inv401kSource) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if !e.Valid() {
		return nil
	}
	enc.EncodeElement(inv401kSources[*e-1], start)
	return nil
}

// NewInv401kSource returns returns an 'enum' value of type inv401kSource given its
// string representation
func NewInv401kSource(s string) (inv401kSource, error) {
	var e inv401kSource
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type subAcctType uint

// SubAcctType* constants represent the sub-account type for a source and/or destination of a transaction. Used in fields named SubAcctFrom, SubAcctTo, SubAcctSec, SubAcctFund, HeldInAcct.
const (
	SubAcctTypeCash subAcctType = 1 + iota
	SubAcctTypeMargin
	SubAcctTypeShort
	SubAcctTypeOther
)

var subAcctTypes = [...]string{"CASH", "MARGIN", "SHORT", "OTHER"}

func (e subAcctType) Valid() bool {
	// This check is mostly out of paranoia, ensuring e != 0 should be
	// sufficient
	return e >= SubAcctTypeCash && e <= SubAcctTypeOther
}

func (e subAcctType) String() string {
	if e.Valid() {
		return subAcctTypes[e-1]
	}
	return fmt.Sprintf("invalid subAcctType (%d)", e)
}

func (e *subAcctType) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range subAcctTypes {
		if s == value {
			*e = subAcctType(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid SubAcctType: \"" + in + "\"")
}

func (e *subAcctType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *subAcctType) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if !e.Valid() {
		return nil
	}
	enc.EncodeElement(subAcctTypes[*e-1], start)
	return nil
}

// NewSubAcctType returns returns an 'enum' value of type subAcctType given its
// string representation
func NewSubAcctType(s string) (subAcctType, error) {
	var e subAcctType
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type buyType uint

// BuyType* constants represent types of purchases
const (
	BuyTypeBuy buyType = 1 + iota
	BuyTypeBuyToCover
)

var buyTypes = [...]string{"BUY", "BUYTOCOVER"}

func (e buyType) Valid() bool {
	// This check is mostly out of paranoia, ensuring e != 0 should be
	// sufficient
	return e >= BuyTypeBuy && e <= BuyTypeBuyToCover
}

func (e buyType) String() string {
	if e.Valid() {
		return buyTypes[e-1]
	}
	return fmt.Sprintf("invalid buyType (%d)", e)
}

func (e *buyType) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range buyTypes {
		if s == value {
			*e = buyType(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid BuyType: \"" + in + "\"")
}

func (e *buyType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *buyType) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if !e.Valid() {
		return nil
	}
	enc.EncodeElement(buyTypes[*e-1], start)
	return nil
}

// NewBuyType returns returns an 'enum' value of type buyType given its
// string representation
func NewBuyType(s string) (buyType, error) {
	var e buyType
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type optAction uint

// OptAction* constants represent types of actions for options
const (
	OptActionExercise optAction = 1 + iota
	OptActionAssign
	OptActionExpire
)

var optActions = [...]string{"EXERCISE", "ASSIGN", "EXPIRE"}

func (e optAction) Valid() bool {
	// This check is mostly out of paranoia, ensuring e != 0 should be
	// sufficient
	return e >= OptActionExercise && e <= OptActionExpire
}

func (e optAction) String() string {
	if e.Valid() {
		return optActions[e-1]
	}
	return fmt.Sprintf("invalid optAction (%d)", e)
}

func (e *optAction) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range optActions {
		if s == value {
			*e = optAction(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid OptAction: \"" + in + "\"")
}

func (e *optAction) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *optAction) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if !e.Valid() {
		return nil
	}
	enc.EncodeElement(optActions[*e-1], start)
	return nil
}

// NewOptAction returns returns an 'enum' value of type optAction given its
// string representation
func NewOptAction(s string) (optAction, error) {
	var e optAction
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type tferAction uint

// TferAction* constants represent whether the transfer is into or out of this account
const (
	TferActionIn tferAction = 1 + iota
	TferActionOut
)

var tferActions = [...]string{"IN", "OUT"}

func (e tferAction) Valid() bool {
	// This check is mostly out of paranoia, ensuring e != 0 should be
	// sufficient
	return e >= TferActionIn && e <= TferActionOut
}

func (e tferAction) String() string {
	if e.Valid() {
		return tferActions[e-1]
	}
	return fmt.Sprintf("invalid tferAction (%d)", e)
}

func (e *tferAction) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range tferActions {
		if s == value {
			*e = tferAction(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid TferAction: \"" + in + "\"")
}

func (e *tferAction) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *tferAction) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if !e.Valid() {
		return nil
	}
	enc.EncodeElement(tferActions[*e-1], start)
	return nil
}

// NewTferAction returns returns an 'enum' value of type tferAction given its
// string representation
func NewTferAction(s string) (tferAction, error) {
	var e tferAction
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type posType uint

// PosType* constants represent position type
const (
	PosTypeLong posType = 1 + iota
	PosTypeShort
)

var posTypes = [...]string{"LONG", "SHORT"}

func (e posType) Valid() bool {
	// This check is mostly out of paranoia, ensuring e != 0 should be
	// sufficient
	return e >= PosTypeLong && e <= PosTypeShort
}

func (e posType) String() string {
	if e.Valid() {
		return posTypes[e-1]
	}
	return fmt.Sprintf("invalid posType (%d)", e)
}

func (e *posType) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range posTypes {
		if s == value {
			*e = posType(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid PosType: \"" + in + "\"")
}

func (e *posType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *posType) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if !e.Valid() {
		return nil
	}
	enc.EncodeElement(posTypes[*e-1], start)
	return nil
}

// NewPosType returns returns an 'enum' value of type posType given its
// string representation
func NewPosType(s string) (posType, error) {
	var e posType
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type secured uint

// Secured* constants represent how an option is secured
const (
	SecuredNaked secured = 1 + iota
	SecuredCovered
)

var secureds = [...]string{"NAKED", "COVERED"}

func (e secured) Valid() bool {
	// This check is mostly out of paranoia, ensuring e != 0 should be
	// sufficient
	return e >= SecuredNaked && e <= SecuredCovered
}

func (e secured) String() string {
	if e.Valid() {
		return secureds[e-1]
	}
	return fmt.Sprintf("invalid secured (%d)", e)
}

func (e *secured) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range secureds {
		if s == value {
			*e = secured(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid Secured: \"" + in + "\"")
}

func (e *secured) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *secured) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if !e.Valid() {
		return nil
	}
	enc.EncodeElement(secureds[*e-1], start)
	return nil
}

// NewSecured returns returns an 'enum' value of type secured given its
// string representation
func NewSecured(s string) (secured, error) {
	var e secured
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type duration uint

// Duration* constants represent how long the investment order is good for
const (
	DurationDay duration = 1 + iota
	DurationGoodTilCancel
	DurationImmediate
)

var durations = [...]string{"DAY", "GOODTILCANCEL", "IMMEDIATE"}

func (e duration) Valid() bool {
	// This check is mostly out of paranoia, ensuring e != 0 should be
	// sufficient
	return e >= DurationDay && e <= DurationImmediate
}

func (e duration) String() string {
	if e.Valid() {
		return durations[e-1]
	}
	return fmt.Sprintf("invalid duration (%d)", e)
}

func (e *duration) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range durations {
		if s == value {
			*e = duration(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid Duration: \"" + in + "\"")
}

func (e *duration) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *duration) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if !e.Valid() {
		return nil
	}
	enc.EncodeElement(durations[*e-1], start)
	return nil
}

// NewDuration returns returns an 'enum' value of type duration given its
// string representation
func NewDuration(s string) (duration, error) {
	var e duration
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type restriction uint

// Restriction* constants represent a special restriction on an investment order
const (
	RestrictionAllOrNone restriction = 1 + iota
	RestrictionMinUnits
	RestrictionNone
)

var restrictions = [...]string{"ALLORNONE", "MINUNITS", "NONE"}

func (e restriction) Valid() bool {
	// This check is mostly out of paranoia, ensuring e != 0 should be
	// sufficient
	return e >= RestrictionAllOrNone && e <= RestrictionNone
}

func (e restriction) String() string {
	if e.Valid() {
		return restrictions[e-1]
	}
	return fmt.Sprintf("invalid restriction (%d)", e)
}

func (e *restriction) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range restrictions {
		if s == value {
			*e = restriction(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid Restriction: \"" + in + "\"")
}

func (e *restriction) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *restriction) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if !e.Valid() {
		return nil
	}
	enc.EncodeElement(restrictions[*e-1], start)
	return nil
}

// NewRestriction returns returns an 'enum' value of type restriction given its
// string representation
func NewRestriction(s string) (restriction, error) {
	var e restriction
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type unitType uint

// UnitType* constants represent type of the UNITS value
const (
	UnitTypeShares unitType = 1 + iota
	UnitTypeCurrency
)

var unitTypes = [...]string{"SHARES", "CURRENCY"}

func (e unitType) Valid() bool {
	// This check is mostly out of paranoia, ensuring e != 0 should be
	// sufficient
	return e >= UnitTypeShares && e <= UnitTypeCurrency
}

func (e unitType) String() string {
	if e.Valid() {
		return unitTypes[e-1]
	}
	return fmt.Sprintf("invalid unitType (%d)", e)
}

func (e *unitType) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range unitTypes {
		if s == value {
			*e = unitType(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid UnitType: \"" + in + "\"")
}

func (e *unitType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *unitType) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if !e.Valid() {
		return nil
	}
	enc.EncodeElement(unitTypes[*e-1], start)
	return nil
}

// NewUnitType returns returns an 'enum' value of type unitType given its
// string representation
func NewUnitType(s string) (unitType, error) {
	var e unitType
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type optBuyType uint

// OptBuyType* constants represent types of purchases for options
const (
	OptBuyTypeBuyToOpen optBuyType = 1 + iota
	OptBuyTypeBuyToClose
)

var optBuyTypes = [...]string{"BUYTOOPEN", "BUYTOCLOSE"}

func (e optBuyType) Valid() bool {
	// This check is mostly out of paranoia, ensuring e != 0 should be
	// sufficient
	return e >= OptBuyTypeBuyToOpen && e <= OptBuyTypeBuyToClose
}

func (e optBuyType) String() string {
	if e.Valid() {
		return optBuyTypes[e-1]
	}
	return fmt.Sprintf("invalid optBuyType (%d)", e)
}

func (e *optBuyType) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range optBuyTypes {
		if s == value {
			*e = optBuyType(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid OptBuyType: \"" + in + "\"")
}

func (e *optBuyType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *optBuyType) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if !e.Valid() {
		return nil
	}
	enc.EncodeElement(optBuyTypes[*e-1], start)
	return nil
}

// NewOptBuyType returns returns an 'enum' value of type optBuyType given its
// string representation
func NewOptBuyType(s string) (optBuyType, error) {
	var e optBuyType
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type sellType uint

// SellType* constants represent types of sales
const (
	SellTypeSell sellType = 1 + iota
	SellTypeSellShort
)

var sellTypes = [...]string{"SELL", "SELLSHORT"}

func (e sellType) Valid() bool {
	// This check is mostly out of paranoia, ensuring e != 0 should be
	// sufficient
	return e >= SellTypeSell && e <= SellTypeSellShort
}

func (e sellType) String() string {
	if e.Valid() {
		return sellTypes[e-1]
	}
	return fmt.Sprintf("invalid sellType (%d)", e)
}

func (e *sellType) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range sellTypes {
		if s == value {
			*e = sellType(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid SellType: \"" + in + "\"")
}

func (e *sellType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *sellType) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if !e.Valid() {
		return nil
	}
	enc.EncodeElement(sellTypes[*e-1], start)
	return nil
}

// NewSellType returns returns an 'enum' value of type sellType given its
// string representation
func NewSellType(s string) (sellType, error) {
	var e sellType
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type loanPmtFreq uint

// LoanPmtFreq* constants represent the frequency of loan payments
const (
	LoanPmtFreqWeekly loanPmtFreq = 1 + iota
	LoanPmtFreqBiweekly
	LoanPmtFreqTwiceMonthly
	LoanPmtFreqMonthly
	LoanPmtFreqFourWeeks
	LoanPmtFreqBiMonthly
	LoanPmtFreqQuarterly
	LoanPmtFreqSemiannually
	LoanPmtFreqAnnually
	LoanPmtFreqOther
)

var loanPmtFreqs = [...]string{"WEEKLY", "BIWEEKLY", "TWICEMONTHLY", "MONTHLY", "FOURWEEKS", "BIMONTHLY", "QUARTERLY", "SEMIANNUALLY", "ANNUALLY", "OTHER"}

func (e loanPmtFreq) Valid() bool {
	// This check is mostly out of paranoia, ensuring e != 0 should be
	// sufficient
	return e >= LoanPmtFreqWeekly && e <= LoanPmtFreqOther
}

func (e loanPmtFreq) String() string {
	if e.Valid() {
		return loanPmtFreqs[e-1]
	}
	return fmt.Sprintf("invalid loanPmtFreq (%d)", e)
}

func (e *loanPmtFreq) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range loanPmtFreqs {
		if s == value {
			*e = loanPmtFreq(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid LoanPmtFreq: \"" + in + "\"")
}

func (e *loanPmtFreq) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *loanPmtFreq) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if !e.Valid() {
		return nil
	}
	enc.EncodeElement(loanPmtFreqs[*e-1], start)
	return nil
}

// NewLoanPmtFreq returns returns an 'enum' value of type loanPmtFreq given its
// string representation
func NewLoanPmtFreq(s string) (loanPmtFreq, error) {
	var e loanPmtFreq
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type incomeType uint

// IncomeType* constants represent types of investment income
const (
	IncomeTypeCGLong incomeType = 1 + iota
	IncomeTypeCGShort
	IncomeTypeDiv
	IncomeTypeInterest
	IncomeTypeMisc
)

var incomeTypes = [...]string{"CGLONG", "CGSHORT", "DIV", "INTEREST", "MISC"}

func (e incomeType) Valid() bool {
	// This check is mostly out of paranoia, ensuring e != 0 should be
	// sufficient
	return e >= IncomeTypeCGLong && e <= IncomeTypeMisc
}

func (e incomeType) String() string {
	if e.Valid() {
		return incomeTypes[e-1]
	}
	return fmt.Sprintf("invalid incomeType (%d)", e)
}

func (e *incomeType) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range incomeTypes {
		if s == value {
			*e = incomeType(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid IncomeType: \"" + in + "\"")
}

func (e *incomeType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *incomeType) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if !e.Valid() {
		return nil
	}
	enc.EncodeElement(incomeTypes[*e-1], start)
	return nil
}

// NewIncomeType returns returns an 'enum' value of type incomeType given its
// string representation
func NewIncomeType(s string) (incomeType, error) {
	var e incomeType
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type sellReason uint

// SellReason* constants represent the reason the sell of a debt security was generated: CALL (the debt was called), SELL (the debt was sold), MATURITY (the debt reached maturity)
const (
	SellReasonCall sellReason = 1 + iota
	SellReasonSell
	SellReasonMaturity
)

var sellReasons = [...]string{"CALL", "SELL", "MATURITY"}

func (e sellReason) Valid() bool {
	// This check is mostly out of paranoia, ensuring e != 0 should be
	// sufficient
	return e >= SellReasonCall && e <= SellReasonMaturity
}

func (e sellReason) String() string {
	if e.Valid() {
		return sellReasons[e-1]
	}
	return fmt.Sprintf("invalid sellReason (%d)", e)
}

func (e *sellReason) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range sellReasons {
		if s == value {
			*e = sellReason(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid SellReason: \"" + in + "\"")
}

func (e *sellReason) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *sellReason) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if !e.Valid() {
		return nil
	}
	enc.EncodeElement(sellReasons[*e-1], start)
	return nil
}

// NewSellReason returns returns an 'enum' value of type sellReason given its
// string representation
func NewSellReason(s string) (sellReason, error) {
	var e sellReason
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type optSellType uint

// OptSellType* constants represent types of sales for options
const (
	OptSellTypeSellToClose optSellType = 1 + iota
	OptSellTypeSellToOpen
)

var optSellTypes = [...]string{"SELLTOCLOSE", "SELLTOOPEN"}

func (e optSellType) Valid() bool {
	// This check is mostly out of paranoia, ensuring e != 0 should be
	// sufficient
	return e >= OptSellTypeSellToClose && e <= OptSellTypeSellToOpen
}

func (e optSellType) String() string {
	if e.Valid() {
		return optSellTypes[e-1]
	}
	return fmt.Sprintf("invalid optSellType (%d)", e)
}

func (e *optSellType) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range optSellTypes {
		if s == value {
			*e = optSellType(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid OptSellType: \"" + in + "\"")
}

func (e *optSellType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *optSellType) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if !e.Valid() {
		return nil
	}
	enc.EncodeElement(optSellTypes[*e-1], start)
	return nil
}

// NewOptSellType returns returns an 'enum' value of type optSellType given its
// string representation
func NewOptSellType(s string) (optSellType, error) {
	var e optSellType
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type relType uint

// RelType* constants represent related option transaction types
const (
	RelTypeSpread relType = 1 + iota
	RelTypeStraddle
	RelTypeNone
	RelTypeOther
)

var relTypes = [...]string{"SPREAD", "STRADDLE", "NONE", "OTHER"}

func (e relType) Valid() bool {
	// This check is mostly out of paranoia, ensuring e != 0 should be
	// sufficient
	return e >= RelTypeSpread && e <= RelTypeOther
}

func (e relType) String() string {
	if e.Valid() {
		return relTypes[e-1]
	}
	return fmt.Sprintf("invalid relType (%d)", e)
}

func (e *relType) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range relTypes {
		if s == value {
			*e = relType(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid RelType: \"" + in + "\"")
}

func (e *relType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *relType) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if !e.Valid() {
		return nil
	}
	enc.EncodeElement(relTypes[*e-1], start)
	return nil
}

// NewRelType returns returns an 'enum' value of type relType given its
// string representation
func NewRelType(s string) (relType, error) {
	var e relType
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type charType uint

// CharType* constants represent types of characters allowed in password
const (
	CharTypeAlphaOnly charType = 1 + iota
	CharTypeNumericOnly
	CharTypeAlphaOrNumeric
	CharTypeAlphaAndNumeric
)

var charTypes = [...]string{"ALPHAONLY", "NUMERICONLY", "ALPHAORNUMERIC", "ALPHAANDNUMERIC"}

func (e charType) Valid() bool {
	// This check is mostly out of paranoia, ensuring e != 0 should be
	// sufficient
	return e >= CharTypeAlphaOnly && e <= CharTypeAlphaAndNumeric
}

func (e charType) String() string {
	if e.Valid() {
		return charTypes[e-1]
	}
	return fmt.Sprintf("invalid charType (%d)", e)
}

func (e *charType) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range charTypes {
		if s == value {
			*e = charType(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid CharType: \"" + in + "\"")
}

func (e *charType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *charType) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if !e.Valid() {
		return nil
	}
	enc.EncodeElement(charTypes[*e-1], start)
	return nil
}

// NewCharType returns returns an 'enum' value of type charType given its
// string representation
func NewCharType(s string) (charType, error) {
	var e charType
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type syncMode uint

// SyncMode* constants represent data synchronization mode supported (see OFX spec for more details)
const (
	SyncModeFull syncMode = 1 + iota
	SyncModeLite
)

var syncModes = [...]string{"FULL", "LITE"}

func (e syncMode) Valid() bool {
	// This check is mostly out of paranoia, ensuring e != 0 should be
	// sufficient
	return e >= SyncModeFull && e <= SyncModeLite
}

func (e syncMode) String() string {
	if e.Valid() {
		return syncModes[e-1]
	}
	return fmt.Sprintf("invalid syncMode (%d)", e)
}

func (e *syncMode) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range syncModes {
		if s == value {
			*e = syncMode(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid SyncMode: \"" + in + "\"")
}

func (e *syncMode) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *syncMode) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if !e.Valid() {
		return nil
	}
	enc.EncodeElement(syncModes[*e-1], start)
	return nil
}

// NewSyncMode returns returns an 'enum' value of type syncMode given its
// string representation
func NewSyncMode(s string) (syncMode, error) {
	var e syncMode
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type ofxSec uint

// OfxSec* constants represent the type of application-level security required for the message set
const (
	OfxSecNone ofxSec = 1 + iota
	OfxSecType1
)

var ofxSecs = [...]string{"NONE", "TYPE 1"}

func (e ofxSec) Valid() bool {
	// This check is mostly out of paranoia, ensuring e != 0 should be
	// sufficient
	return e >= OfxSecNone && e <= OfxSecType1
}

func (e ofxSec) String() string {
	if e.Valid() {
		return ofxSecs[e-1]
	}
	return fmt.Sprintf("invalid ofxSec (%d)", e)
}

func (e *ofxSec) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range ofxSecs {
		if s == value {
			*e = ofxSec(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid OfxSec: \"" + in + "\"")
}

func (e *ofxSec) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *ofxSec) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if !e.Valid() {
		return nil
	}
	enc.EncodeElement(ofxSecs[*e-1], start)
	return nil
}

// NewOfxSec returns returns an 'enum' value of type ofxSec given its
// string representation
func NewOfxSec(s string) (ofxSec, error) {
	var e ofxSec
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type debtType uint

// DebtType* constants represent debt type
const (
	DebtTypeCoupon debtType = 1 + iota
	DebtTypeZero
)

var debtTypes = [...]string{"COUPON", "ZERO"}

func (e debtType) Valid() bool {
	// This check is mostly out of paranoia, ensuring e != 0 should be
	// sufficient
	return e >= DebtTypeCoupon && e <= DebtTypeZero
}

func (e debtType) String() string {
	if e.Valid() {
		return debtTypes[e-1]
	}
	return fmt.Sprintf("invalid debtType (%d)", e)
}

func (e *debtType) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range debtTypes {
		if s == value {
			*e = debtType(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid DebtType: \"" + in + "\"")
}

func (e *debtType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *debtType) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if !e.Valid() {
		return nil
	}
	enc.EncodeElement(debtTypes[*e-1], start)
	return nil
}

// NewDebtType returns returns an 'enum' value of type debtType given its
// string representation
func NewDebtType(s string) (debtType, error) {
	var e debtType
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type debtClass uint

// DebtClass* constants represent the class of debt
const (
	DebtClassTreasury debtClass = 1 + iota
	DebtClassMunicipal
	DebtClassCorporate
	DebtClassOther
)

var debtClasss = [...]string{"TREASURY", "MUNICIPAL", "CORPORATE", "OTHER"}

func (e debtClass) Valid() bool {
	// This check is mostly out of paranoia, ensuring e != 0 should be
	// sufficient
	return e >= DebtClassTreasury && e <= DebtClassOther
}

func (e debtClass) String() string {
	if e.Valid() {
		return debtClasss[e-1]
	}
	return fmt.Sprintf("invalid debtClass (%d)", e)
}

func (e *debtClass) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range debtClasss {
		if s == value {
			*e = debtClass(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid DebtClass: \"" + in + "\"")
}

func (e *debtClass) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *debtClass) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if !e.Valid() {
		return nil
	}
	enc.EncodeElement(debtClasss[*e-1], start)
	return nil
}

// NewDebtClass returns returns an 'enum' value of type debtClass given its
// string representation
func NewDebtClass(s string) (debtClass, error) {
	var e debtClass
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type couponFreq uint

// CouponFreq* constants represent when debt coupons mature
const (
	CouponFreqMonthly couponFreq = 1 + iota
	CouponFreqQuarterly
	CouponFreqSemiannual
	CouponFreqAnnual
	CouponFreqOther
)

var couponFreqs = [...]string{"MONTHLY", "QUARTERLY", "SEMIANNUAL", "ANNUAL", "OTHER"}

func (e couponFreq) Valid() bool {
	// This check is mostly out of paranoia, ensuring e != 0 should be
	// sufficient
	return e >= CouponFreqMonthly && e <= CouponFreqOther
}

func (e couponFreq) String() string {
	if e.Valid() {
		return couponFreqs[e-1]
	}
	return fmt.Sprintf("invalid couponFreq (%d)", e)
}

func (e *couponFreq) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range couponFreqs {
		if s == value {
			*e = couponFreq(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid CouponFreq: \"" + in + "\"")
}

func (e *couponFreq) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *couponFreq) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if !e.Valid() {
		return nil
	}
	enc.EncodeElement(couponFreqs[*e-1], start)
	return nil
}

// NewCouponFreq returns returns an 'enum' value of type couponFreq given its
// string representation
func NewCouponFreq(s string) (couponFreq, error) {
	var e couponFreq
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type callType uint

// CallType* constants represent type of next call (for a debt)
const (
	CallTypeCall callType = 1 + iota
	CallTypePut
	CallTypePrefund
	CallTypeMaturity
)

var callTypes = [...]string{"CALL", "PUT", "PREFUND", "MATURITY"}

func (e callType) Valid() bool {
	// This check is mostly out of paranoia, ensuring e != 0 should be
	// sufficient
	return e >= CallTypeCall && e <= CallTypeMaturity
}

func (e callType) String() string {
	if e.Valid() {
		return callTypes[e-1]
	}
	return fmt.Sprintf("invalid callType (%d)", e)
}

func (e *callType) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range callTypes {
		if s == value {
			*e = callType(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid CallType: \"" + in + "\"")
}

func (e *callType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *callType) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if !e.Valid() {
		return nil
	}
	enc.EncodeElement(callTypes[*e-1], start)
	return nil
}

// NewCallType returns returns an 'enum' value of type callType given its
// string representation
func NewCallType(s string) (callType, error) {
	var e callType
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type assetClass uint

// AssetClass* constants represent type of asset classes
const (
	AssetClassDomesticBond assetClass = 1 + iota
	AssetClassIntlBond
	AssetClassLargeStock
	AssetClassSmallStock
	AssetClassIntlStock
	AssetClassMoneyMrkt
	AssetClassOther
)

var assetClasss = [...]string{"DOMESTICBOND", "INTLBOND", "LARGESTOCK", "SMALLSTOCK", "INTLSTOCK", "MONEYMRKT", "OTHER"}

func (e assetClass) Valid() bool {
	// This check is mostly out of paranoia, ensuring e != 0 should be
	// sufficient
	return e >= AssetClassDomesticBond && e <= AssetClassOther
}

func (e assetClass) String() string {
	if e.Valid() {
		return assetClasss[e-1]
	}
	return fmt.Sprintf("invalid assetClass (%d)", e)
}

func (e *assetClass) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range assetClasss {
		if s == value {
			*e = assetClass(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid AssetClass: \"" + in + "\"")
}

func (e *assetClass) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *assetClass) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if !e.Valid() {
		return nil
	}
	enc.EncodeElement(assetClasss[*e-1], start)
	return nil
}

// NewAssetClass returns returns an 'enum' value of type assetClass given its
// string representation
func NewAssetClass(s string) (assetClass, error) {
	var e assetClass
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type mfType uint

// MfType* constants represent types of mutual funds
const (
	MfTypeOpenEnd mfType = 1 + iota
	MfTypeCloseEnd
	MfTypeOther
)

var mfTypes = [...]string{"OPENEND", "CLOSEEND", "OTHER"}

func (e mfType) Valid() bool {
	// This check is mostly out of paranoia, ensuring e != 0 should be
	// sufficient
	return e >= MfTypeOpenEnd && e <= MfTypeOther
}

func (e mfType) String() string {
	if e.Valid() {
		return mfTypes[e-1]
	}
	return fmt.Sprintf("invalid mfType (%d)", e)
}

func (e *mfType) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range mfTypes {
		if s == value {
			*e = mfType(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid MfType: \"" + in + "\"")
}

func (e *mfType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *mfType) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if !e.Valid() {
		return nil
	}
	enc.EncodeElement(mfTypes[*e-1], start)
	return nil
}

// NewMfType returns returns an 'enum' value of type mfType given its
// string representation
func NewMfType(s string) (mfType, error) {
	var e mfType
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type optType uint

// OptType* constants represent whether the option is a PUT or a CALL
const (
	OptTypePut optType = 1 + iota
	OptTypeCall
)

var optTypes = [...]string{"PUT", "CALL"}

func (e optType) Valid() bool {
	// This check is mostly out of paranoia, ensuring e != 0 should be
	// sufficient
	return e >= OptTypePut && e <= OptTypeCall
}

func (e optType) String() string {
	if e.Valid() {
		return optTypes[e-1]
	}
	return fmt.Sprintf("invalid optType (%d)", e)
}

func (e *optType) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range optTypes {
		if s == value {
			*e = optType(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid OptType: \"" + in + "\"")
}

func (e *optType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *optType) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if !e.Valid() {
		return nil
	}
	enc.EncodeElement(optTypes[*e-1], start)
	return nil
}

// NewOptType returns returns an 'enum' value of type optType given its
// string representation
func NewOptType(s string) (optType, error) {
	var e optType
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type stockType uint

// StockType* constants represent types of stock
const (
	StockTypeCommon stockType = 1 + iota
	StockTypePreferred
	StockTypeConvertible
	StockTypeOther
)

var stockTypes = [...]string{"COMMON", "PREFERRED", "CONVERTIBLE", "OTHER"}

func (e stockType) Valid() bool {
	// This check is mostly out of paranoia, ensuring e != 0 should be
	// sufficient
	return e >= StockTypeCommon && e <= StockTypeOther
}

func (e stockType) String() string {
	if e.Valid() {
		return stockTypes[e-1]
	}
	return fmt.Sprintf("invalid stockType (%d)", e)
}

func (e *stockType) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range stockTypes {
		if s == value {
			*e = stockType(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid StockType: \"" + in + "\"")
}

func (e *stockType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *stockType) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if !e.Valid() {
		return nil
	}
	enc.EncodeElement(stockTypes[*e-1], start)
	return nil
}

// NewStockType returns returns an 'enum' value of type stockType given its
// string representation
func NewStockType(s string) (stockType, error) {
	var e stockType
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type holderType uint

// HolderType* constants represent how the account is held
const (
	HolderTypeIndividual holderType = 1 + iota
	HolderTypeJoint
	HolderTypeCustodial
	HolderTypeTrust
	HolderTypeOther
)

var holderTypes = [...]string{"INDIVIDUAL", "JOINT", "CUSTODIAL", "TRUST", "OTHER"}

func (e holderType) Valid() bool {
	// This check is mostly out of paranoia, ensuring e != 0 should be
	// sufficient
	return e >= HolderTypeIndividual && e <= HolderTypeOther
}

func (e holderType) String() string {
	if e.Valid() {
		return holderTypes[e-1]
	}
	return fmt.Sprintf("invalid holderType (%d)", e)
}

func (e *holderType) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range holderTypes {
		if s == value {
			*e = holderType(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid HolderType: \"" + in + "\"")
}

func (e *holderType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *holderType) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if !e.Valid() {
		return nil
	}
	enc.EncodeElement(holderTypes[*e-1], start)
	return nil
}

// NewHolderType returns returns an 'enum' value of type holderType given its
// string representation
func NewHolderType(s string) (holderType, error) {
	var e holderType
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type acctClassification uint

// AcctClassification* constants represent the type of an account
const (
	AcctClassificationPersonal acctClassification = 1 + iota
	AcctClassificationBusiness
	AcctClassificationCorporate
	AcctClassificationOther
)

var acctClassifications = [...]string{"PERSONAL", "BUSINESS", "CORPORATE", "OTHER"}

func (e acctClassification) Valid() bool {
	// This check is mostly out of paranoia, ensuring e != 0 should be
	// sufficient
	return e >= AcctClassificationPersonal && e <= AcctClassificationOther
}

func (e acctClassification) String() string {
	if e.Valid() {
		return acctClassifications[e-1]
	}
	return fmt.Sprintf("invalid acctClassification (%d)", e)
}

func (e *acctClassification) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range acctClassifications {
		if s == value {
			*e = acctClassification(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid AcctClassification: \"" + in + "\"")
}

func (e *acctClassification) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *acctClassification) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if !e.Valid() {
		return nil
	}
	enc.EncodeElement(acctClassifications[*e-1], start)
	return nil
}

// NewAcctClassification returns returns an 'enum' value of type acctClassification given its
// string representation
func NewAcctClassification(s string) (acctClassification, error) {
	var e acctClassification
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type svcStatus uint

// SvcStatus* constants represent the status of the account: AVAIL = Available, but not yet requested, PEND = Requested, but not yet available, ACTIVE = In use
const (
	SvcStatusAvail svcStatus = 1 + iota
	SvcStatusPend
	SvcStatusActive
)

var svcStatuss = [...]string{"AVAIL", "PEND", "ACTIVE"}

func (e svcStatus) Valid() bool {
	// This check is mostly out of paranoia, ensuring e != 0 should be
	// sufficient
	return e >= SvcStatusAvail && e <= SvcStatusActive
}

func (e svcStatus) String() string {
	if e.Valid() {
		return svcStatuss[e-1]
	}
	return fmt.Sprintf("invalid svcStatus (%d)", e)
}

func (e *svcStatus) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range svcStatuss {
		if s == value {
			*e = svcStatus(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid SvcStatus: \"" + in + "\"")
}

func (e *svcStatus) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *svcStatus) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if !e.Valid() {
		return nil
	}
	enc.EncodeElement(svcStatuss[*e-1], start)
	return nil
}

// NewSvcStatus returns returns an 'enum' value of type svcStatus given its
// string representation
func NewSvcStatus(s string) (svcStatus, error) {
	var e svcStatus
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}

type usProductType uint

// UsProductType* constants represent type of investment account (in the US)
const (
	UsProductType401K usProductType = 1 + iota
	UsProductType403B
	UsProductTypeIRA
	UsProductTypeKEOGH
	UsProductTypeOther
	UsProductTypeSARSEP
	UsProductTypeSimple
	UsProductTypeNormal
	UsProductTypeTDA
	UsProductTypeTrust
	UsProductTypeUGMA
)

var usProductTypes = [...]string{"401K", "403B", "IRA", "KEOGH", "OTHER", "SARSEP", "SIMPLE", "NORMAL", "TDA", "TRUST", "UGMA"}

func (e usProductType) Valid() bool {
	// This check is mostly out of paranoia, ensuring e != 0 should be
	// sufficient
	return e >= UsProductType401K && e <= UsProductTypeUGMA
}

func (e usProductType) String() string {
	if e.Valid() {
		return usProductTypes[e-1]
	}
	return fmt.Sprintf("invalid usProductType (%d)", e)
}

func (e *usProductType) FromString(in string) error {
	value := strings.TrimSpace(in)

	for i, s := range usProductTypes {
		if s == value {
			*e = usProductType(i + 1)
			return nil
		}
	}
	*e = 0
	return errors.New("Invalid UsProductType: \"" + in + "\"")
}

func (e *usProductType) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	var value string
	err := d.DecodeElement(&value, &start)
	if err != nil {
		return err
	}

	return e.FromString(value)
}

func (e *usProductType) MarshalXML(enc *xml.Encoder, start xml.StartElement) error {
	if !e.Valid() {
		return nil
	}
	enc.EncodeElement(usProductTypes[*e-1], start)
	return nil
}

// NewUsProductType returns returns an 'enum' value of type usProductType given its
// string representation
func NewUsProductType(s string) (usProductType, error) {
	var e usProductType
	err := e.FromString(s)
	if err != nil {
		return 0, err
	}
	return e, nil
}
