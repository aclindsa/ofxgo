package ofxgo

/*
 * Do not edit this file by hand. It is auto-generated by calling `go generate`.
 * To make changes, edit generate_constants.py, re-run `go generate`, and check
 * in the result.
 */

import (
	"strings"
	"testing"

	"github.com/aclindsa/xml"
)

func TestOfxVersion(t *testing.T) {
	e, err := NewOfxVersion("102")
	if err != nil {
		t.Fatalf("Unexpected error creating new OfxVersion from string \"102\"\n")
	}
	if !e.Valid() {
		t.Fatalf("OfxVersion unexpectedly invalid\n")
	}
	err = e.FromString("220")
	if err != nil {
		t.Fatalf("Unexpected error on OfxVersion.FromString(\"220\")\n")
	}
	if e.String() != "220" {
		t.Fatalf("OfxVersion.String() expected to be \"220\"\n")
	}

	marshalHelper(t, "220", &e)

	overwritten, err := NewOfxVersion("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new OfxVersion from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("OfxVersion created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("OfxVersion created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(OfxVersion): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "220", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}

	type SC struct {
		E ofxVersion
	}
	sc := SC{E: e}
	b, err = xml.Marshal(sc)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(struct OfxVersion): %s\n", err)
	}
	if string(b) != "<SC><E>220</E></SC>" {
		t.Fatalf("Expected '%s', got '%s'\n", "<SC><E>220</E></SC>", string(b))
	}
}

func TestAcctType(t *testing.T) {
	e, err := NewAcctType("CHECKING")
	if err != nil {
		t.Fatalf("Unexpected error creating new AcctType from string \"CHECKING\"\n")
	}
	if !e.Valid() {
		t.Fatalf("AcctType unexpectedly invalid\n")
	}
	err = e.FromString("CD")
	if err != nil {
		t.Fatalf("Unexpected error on AcctType.FromString(\"CD\")\n")
	}
	if e.String() != "CD" {
		t.Fatalf("AcctType.String() expected to be \"CD\"\n")
	}

	marshalHelper(t, "CD", &e)

	overwritten, err := NewAcctType("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new AcctType from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("AcctType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("AcctType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(AcctType): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "CD", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}

	type SC struct {
		E acctType
	}
	sc := SC{E: e}
	b, err = xml.Marshal(sc)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(struct AcctType): %s\n", err)
	}
	if string(b) != "<SC><E>CD</E></SC>" {
		t.Fatalf("Expected '%s', got '%s'\n", "<SC><E>CD</E></SC>", string(b))
	}
}

func TestTrnType(t *testing.T) {
	e, err := NewTrnType("CREDIT")
	if err != nil {
		t.Fatalf("Unexpected error creating new TrnType from string \"CREDIT\"\n")
	}
	if !e.Valid() {
		t.Fatalf("TrnType unexpectedly invalid\n")
	}
	err = e.FromString("OTHER")
	if err != nil {
		t.Fatalf("Unexpected error on TrnType.FromString(\"OTHER\")\n")
	}
	if e.String() != "OTHER" {
		t.Fatalf("TrnType.String() expected to be \"OTHER\"\n")
	}

	marshalHelper(t, "OTHER", &e)

	overwritten, err := NewTrnType("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new TrnType from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("TrnType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("TrnType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(TrnType): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "OTHER", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}

	type SC struct {
		E trnType
	}
	sc := SC{E: e}
	b, err = xml.Marshal(sc)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(struct TrnType): %s\n", err)
	}
	if string(b) != "<SC><E>OTHER</E></SC>" {
		t.Fatalf("Expected '%s', got '%s'\n", "<SC><E>OTHER</E></SC>", string(b))
	}
}

func TestImageType(t *testing.T) {
	e, err := NewImageType("STATEMENT")
	if err != nil {
		t.Fatalf("Unexpected error creating new ImageType from string \"STATEMENT\"\n")
	}
	if !e.Valid() {
		t.Fatalf("ImageType unexpectedly invalid\n")
	}
	err = e.FromString("TAX")
	if err != nil {
		t.Fatalf("Unexpected error on ImageType.FromString(\"TAX\")\n")
	}
	if e.String() != "TAX" {
		t.Fatalf("ImageType.String() expected to be \"TAX\"\n")
	}

	marshalHelper(t, "TAX", &e)

	overwritten, err := NewImageType("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new ImageType from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("ImageType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("ImageType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(ImageType): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "TAX", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}

	type SC struct {
		E imageType
	}
	sc := SC{E: e}
	b, err = xml.Marshal(sc)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(struct ImageType): %s\n", err)
	}
	if string(b) != "<SC><E>TAX</E></SC>" {
		t.Fatalf("Expected '%s', got '%s'\n", "<SC><E>TAX</E></SC>", string(b))
	}
}

func TestImageRefType(t *testing.T) {
	e, err := NewImageRefType("OPAQUE")
	if err != nil {
		t.Fatalf("Unexpected error creating new ImageRefType from string \"OPAQUE\"\n")
	}
	if !e.Valid() {
		t.Fatalf("ImageRefType unexpectedly invalid\n")
	}
	err = e.FromString("FORMURL")
	if err != nil {
		t.Fatalf("Unexpected error on ImageRefType.FromString(\"FORMURL\")\n")
	}
	if e.String() != "FORMURL" {
		t.Fatalf("ImageRefType.String() expected to be \"FORMURL\"\n")
	}

	marshalHelper(t, "FORMURL", &e)

	overwritten, err := NewImageRefType("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new ImageRefType from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("ImageRefType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("ImageRefType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(ImageRefType): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "FORMURL", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}

	type SC struct {
		E imageRefType
	}
	sc := SC{E: e}
	b, err = xml.Marshal(sc)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(struct ImageRefType): %s\n", err)
	}
	if string(b) != "<SC><E>FORMURL</E></SC>" {
		t.Fatalf("Expected '%s', got '%s'\n", "<SC><E>FORMURL</E></SC>", string(b))
	}
}

func TestCheckSup(t *testing.T) {
	e, err := NewCheckSup("FRONTONLY")
	if err != nil {
		t.Fatalf("Unexpected error creating new CheckSup from string \"FRONTONLY\"\n")
	}
	if !e.Valid() {
		t.Fatalf("CheckSup unexpectedly invalid\n")
	}
	err = e.FromString("FRONTANDBACK")
	if err != nil {
		t.Fatalf("Unexpected error on CheckSup.FromString(\"FRONTANDBACK\")\n")
	}
	if e.String() != "FRONTANDBACK" {
		t.Fatalf("CheckSup.String() expected to be \"FRONTANDBACK\"\n")
	}

	marshalHelper(t, "FRONTANDBACK", &e)

	overwritten, err := NewCheckSup("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new CheckSup from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("CheckSup created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("CheckSup created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(CheckSup): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "FRONTANDBACK", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}

	type SC struct {
		E checkSup
	}
	sc := SC{E: e}
	b, err = xml.Marshal(sc)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(struct CheckSup): %s\n", err)
	}
	if string(b) != "<SC><E>FRONTANDBACK</E></SC>" {
		t.Fatalf("Expected '%s', got '%s'\n", "<SC><E>FRONTANDBACK</E></SC>", string(b))
	}
}

func TestCorrectAction(t *testing.T) {
	e, err := NewCorrectAction("DELETE")
	if err != nil {
		t.Fatalf("Unexpected error creating new CorrectAction from string \"DELETE\"\n")
	}
	if !e.Valid() {
		t.Fatalf("CorrectAction unexpectedly invalid\n")
	}
	err = e.FromString("REPLACE")
	if err != nil {
		t.Fatalf("Unexpected error on CorrectAction.FromString(\"REPLACE\")\n")
	}
	if e.String() != "REPLACE" {
		t.Fatalf("CorrectAction.String() expected to be \"REPLACE\"\n")
	}

	marshalHelper(t, "REPLACE", &e)

	overwritten, err := NewCorrectAction("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new CorrectAction from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("CorrectAction created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("CorrectAction created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(CorrectAction): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "REPLACE", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}

	type SC struct {
		E correctAction
	}
	sc := SC{E: e}
	b, err = xml.Marshal(sc)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(struct CorrectAction): %s\n", err)
	}
	if string(b) != "<SC><E>REPLACE</E></SC>" {
		t.Fatalf("Expected '%s', got '%s'\n", "<SC><E>REPLACE</E></SC>", string(b))
	}
}

func TestBalType(t *testing.T) {
	e, err := NewBalType("DOLLAR")
	if err != nil {
		t.Fatalf("Unexpected error creating new BalType from string \"DOLLAR\"\n")
	}
	if !e.Valid() {
		t.Fatalf("BalType unexpectedly invalid\n")
	}
	err = e.FromString("NUMBER")
	if err != nil {
		t.Fatalf("Unexpected error on BalType.FromString(\"NUMBER\")\n")
	}
	if e.String() != "NUMBER" {
		t.Fatalf("BalType.String() expected to be \"NUMBER\"\n")
	}

	marshalHelper(t, "NUMBER", &e)

	overwritten, err := NewBalType("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new BalType from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("BalType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("BalType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(BalType): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "NUMBER", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}

	type SC struct {
		E balType
	}
	sc := SC{E: e}
	b, err = xml.Marshal(sc)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(struct BalType): %s\n", err)
	}
	if string(b) != "<SC><E>NUMBER</E></SC>" {
		t.Fatalf("Expected '%s', got '%s'\n", "<SC><E>NUMBER</E></SC>", string(b))
	}
}

func TestInv401kSource(t *testing.T) {
	e, err := NewInv401kSource("PRETAX")
	if err != nil {
		t.Fatalf("Unexpected error creating new Inv401kSource from string \"PRETAX\"\n")
	}
	if !e.Valid() {
		t.Fatalf("Inv401kSource unexpectedly invalid\n")
	}
	err = e.FromString("OTHERNONVEST")
	if err != nil {
		t.Fatalf("Unexpected error on Inv401kSource.FromString(\"OTHERNONVEST\")\n")
	}
	if e.String() != "OTHERNONVEST" {
		t.Fatalf("Inv401kSource.String() expected to be \"OTHERNONVEST\"\n")
	}

	marshalHelper(t, "OTHERNONVEST", &e)

	overwritten, err := NewInv401kSource("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new Inv401kSource from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("Inv401kSource created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("Inv401kSource created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(Inv401kSource): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "OTHERNONVEST", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}

	type SC struct {
		E inv401kSource
	}
	sc := SC{E: e}
	b, err = xml.Marshal(sc)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(struct Inv401kSource): %s\n", err)
	}
	if string(b) != "<SC><E>OTHERNONVEST</E></SC>" {
		t.Fatalf("Expected '%s', got '%s'\n", "<SC><E>OTHERNONVEST</E></SC>", string(b))
	}
}

func TestSubAcctType(t *testing.T) {
	e, err := NewSubAcctType("CASH")
	if err != nil {
		t.Fatalf("Unexpected error creating new SubAcctType from string \"CASH\"\n")
	}
	if !e.Valid() {
		t.Fatalf("SubAcctType unexpectedly invalid\n")
	}
	err = e.FromString("OTHER")
	if err != nil {
		t.Fatalf("Unexpected error on SubAcctType.FromString(\"OTHER\")\n")
	}
	if e.String() != "OTHER" {
		t.Fatalf("SubAcctType.String() expected to be \"OTHER\"\n")
	}

	marshalHelper(t, "OTHER", &e)

	overwritten, err := NewSubAcctType("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new SubAcctType from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("SubAcctType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("SubAcctType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(SubAcctType): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "OTHER", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}

	type SC struct {
		E subAcctType
	}
	sc := SC{E: e}
	b, err = xml.Marshal(sc)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(struct SubAcctType): %s\n", err)
	}
	if string(b) != "<SC><E>OTHER</E></SC>" {
		t.Fatalf("Expected '%s', got '%s'\n", "<SC><E>OTHER</E></SC>", string(b))
	}
}

func TestBuyType(t *testing.T) {
	e, err := NewBuyType("BUY")
	if err != nil {
		t.Fatalf("Unexpected error creating new BuyType from string \"BUY\"\n")
	}
	if !e.Valid() {
		t.Fatalf("BuyType unexpectedly invalid\n")
	}
	err = e.FromString("BUYTOCOVER")
	if err != nil {
		t.Fatalf("Unexpected error on BuyType.FromString(\"BUYTOCOVER\")\n")
	}
	if e.String() != "BUYTOCOVER" {
		t.Fatalf("BuyType.String() expected to be \"BUYTOCOVER\"\n")
	}

	marshalHelper(t, "BUYTOCOVER", &e)

	overwritten, err := NewBuyType("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new BuyType from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("BuyType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("BuyType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(BuyType): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "BUYTOCOVER", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}

	type SC struct {
		E buyType
	}
	sc := SC{E: e}
	b, err = xml.Marshal(sc)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(struct BuyType): %s\n", err)
	}
	if string(b) != "<SC><E>BUYTOCOVER</E></SC>" {
		t.Fatalf("Expected '%s', got '%s'\n", "<SC><E>BUYTOCOVER</E></SC>", string(b))
	}
}

func TestOptAction(t *testing.T) {
	e, err := NewOptAction("EXERCISE")
	if err != nil {
		t.Fatalf("Unexpected error creating new OptAction from string \"EXERCISE\"\n")
	}
	if !e.Valid() {
		t.Fatalf("OptAction unexpectedly invalid\n")
	}
	err = e.FromString("EXPIRE")
	if err != nil {
		t.Fatalf("Unexpected error on OptAction.FromString(\"EXPIRE\")\n")
	}
	if e.String() != "EXPIRE" {
		t.Fatalf("OptAction.String() expected to be \"EXPIRE\"\n")
	}

	marshalHelper(t, "EXPIRE", &e)

	overwritten, err := NewOptAction("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new OptAction from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("OptAction created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("OptAction created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(OptAction): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "EXPIRE", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}

	type SC struct {
		E optAction
	}
	sc := SC{E: e}
	b, err = xml.Marshal(sc)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(struct OptAction): %s\n", err)
	}
	if string(b) != "<SC><E>EXPIRE</E></SC>" {
		t.Fatalf("Expected '%s', got '%s'\n", "<SC><E>EXPIRE</E></SC>", string(b))
	}
}

func TestTferAction(t *testing.T) {
	e, err := NewTferAction("IN")
	if err != nil {
		t.Fatalf("Unexpected error creating new TferAction from string \"IN\"\n")
	}
	if !e.Valid() {
		t.Fatalf("TferAction unexpectedly invalid\n")
	}
	err = e.FromString("OUT")
	if err != nil {
		t.Fatalf("Unexpected error on TferAction.FromString(\"OUT\")\n")
	}
	if e.String() != "OUT" {
		t.Fatalf("TferAction.String() expected to be \"OUT\"\n")
	}

	marshalHelper(t, "OUT", &e)

	overwritten, err := NewTferAction("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new TferAction from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("TferAction created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("TferAction created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(TferAction): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "OUT", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}

	type SC struct {
		E tferAction
	}
	sc := SC{E: e}
	b, err = xml.Marshal(sc)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(struct TferAction): %s\n", err)
	}
	if string(b) != "<SC><E>OUT</E></SC>" {
		t.Fatalf("Expected '%s', got '%s'\n", "<SC><E>OUT</E></SC>", string(b))
	}
}

func TestPosType(t *testing.T) {
	e, err := NewPosType("LONG")
	if err != nil {
		t.Fatalf("Unexpected error creating new PosType from string \"LONG\"\n")
	}
	if !e.Valid() {
		t.Fatalf("PosType unexpectedly invalid\n")
	}
	err = e.FromString("SHORT")
	if err != nil {
		t.Fatalf("Unexpected error on PosType.FromString(\"SHORT\")\n")
	}
	if e.String() != "SHORT" {
		t.Fatalf("PosType.String() expected to be \"SHORT\"\n")
	}

	marshalHelper(t, "SHORT", &e)

	overwritten, err := NewPosType("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new PosType from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("PosType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("PosType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(PosType): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "SHORT", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}

	type SC struct {
		E posType
	}
	sc := SC{E: e}
	b, err = xml.Marshal(sc)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(struct PosType): %s\n", err)
	}
	if string(b) != "<SC><E>SHORT</E></SC>" {
		t.Fatalf("Expected '%s', got '%s'\n", "<SC><E>SHORT</E></SC>", string(b))
	}
}

func TestSecured(t *testing.T) {
	e, err := NewSecured("NAKED")
	if err != nil {
		t.Fatalf("Unexpected error creating new Secured from string \"NAKED\"\n")
	}
	if !e.Valid() {
		t.Fatalf("Secured unexpectedly invalid\n")
	}
	err = e.FromString("COVERED")
	if err != nil {
		t.Fatalf("Unexpected error on Secured.FromString(\"COVERED\")\n")
	}
	if e.String() != "COVERED" {
		t.Fatalf("Secured.String() expected to be \"COVERED\"\n")
	}

	marshalHelper(t, "COVERED", &e)

	overwritten, err := NewSecured("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new Secured from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("Secured created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("Secured created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(Secured): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "COVERED", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}

	type SC struct {
		E secured
	}
	sc := SC{E: e}
	b, err = xml.Marshal(sc)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(struct Secured): %s\n", err)
	}
	if string(b) != "<SC><E>COVERED</E></SC>" {
		t.Fatalf("Expected '%s', got '%s'\n", "<SC><E>COVERED</E></SC>", string(b))
	}
}

func TestDuration(t *testing.T) {
	e, err := NewDuration("DAY")
	if err != nil {
		t.Fatalf("Unexpected error creating new Duration from string \"DAY\"\n")
	}
	if !e.Valid() {
		t.Fatalf("Duration unexpectedly invalid\n")
	}
	err = e.FromString("IMMEDIATE")
	if err != nil {
		t.Fatalf("Unexpected error on Duration.FromString(\"IMMEDIATE\")\n")
	}
	if e.String() != "IMMEDIATE" {
		t.Fatalf("Duration.String() expected to be \"IMMEDIATE\"\n")
	}

	marshalHelper(t, "IMMEDIATE", &e)

	overwritten, err := NewDuration("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new Duration from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("Duration created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("Duration created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(Duration): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "IMMEDIATE", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}

	type SC struct {
		E duration
	}
	sc := SC{E: e}
	b, err = xml.Marshal(sc)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(struct Duration): %s\n", err)
	}
	if string(b) != "<SC><E>IMMEDIATE</E></SC>" {
		t.Fatalf("Expected '%s', got '%s'\n", "<SC><E>IMMEDIATE</E></SC>", string(b))
	}
}

func TestRestriction(t *testing.T) {
	e, err := NewRestriction("ALLORNONE")
	if err != nil {
		t.Fatalf("Unexpected error creating new Restriction from string \"ALLORNONE\"\n")
	}
	if !e.Valid() {
		t.Fatalf("Restriction unexpectedly invalid\n")
	}
	err = e.FromString("NONE")
	if err != nil {
		t.Fatalf("Unexpected error on Restriction.FromString(\"NONE\")\n")
	}
	if e.String() != "NONE" {
		t.Fatalf("Restriction.String() expected to be \"NONE\"\n")
	}

	marshalHelper(t, "NONE", &e)

	overwritten, err := NewRestriction("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new Restriction from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("Restriction created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("Restriction created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(Restriction): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "NONE", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}

	type SC struct {
		E restriction
	}
	sc := SC{E: e}
	b, err = xml.Marshal(sc)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(struct Restriction): %s\n", err)
	}
	if string(b) != "<SC><E>NONE</E></SC>" {
		t.Fatalf("Expected '%s', got '%s'\n", "<SC><E>NONE</E></SC>", string(b))
	}
}

func TestUnitType(t *testing.T) {
	e, err := NewUnitType("SHARES")
	if err != nil {
		t.Fatalf("Unexpected error creating new UnitType from string \"SHARES\"\n")
	}
	if !e.Valid() {
		t.Fatalf("UnitType unexpectedly invalid\n")
	}
	err = e.FromString("CURRENCY")
	if err != nil {
		t.Fatalf("Unexpected error on UnitType.FromString(\"CURRENCY\")\n")
	}
	if e.String() != "CURRENCY" {
		t.Fatalf("UnitType.String() expected to be \"CURRENCY\"\n")
	}

	marshalHelper(t, "CURRENCY", &e)

	overwritten, err := NewUnitType("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new UnitType from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("UnitType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("UnitType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(UnitType): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "CURRENCY", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}

	type SC struct {
		E unitType
	}
	sc := SC{E: e}
	b, err = xml.Marshal(sc)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(struct UnitType): %s\n", err)
	}
	if string(b) != "<SC><E>CURRENCY</E></SC>" {
		t.Fatalf("Expected '%s', got '%s'\n", "<SC><E>CURRENCY</E></SC>", string(b))
	}
}

func TestOptBuyType(t *testing.T) {
	e, err := NewOptBuyType("BUYTOOPEN")
	if err != nil {
		t.Fatalf("Unexpected error creating new OptBuyType from string \"BUYTOOPEN\"\n")
	}
	if !e.Valid() {
		t.Fatalf("OptBuyType unexpectedly invalid\n")
	}
	err = e.FromString("BUYTOCLOSE")
	if err != nil {
		t.Fatalf("Unexpected error on OptBuyType.FromString(\"BUYTOCLOSE\")\n")
	}
	if e.String() != "BUYTOCLOSE" {
		t.Fatalf("OptBuyType.String() expected to be \"BUYTOCLOSE\"\n")
	}

	marshalHelper(t, "BUYTOCLOSE", &e)

	overwritten, err := NewOptBuyType("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new OptBuyType from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("OptBuyType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("OptBuyType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(OptBuyType): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "BUYTOCLOSE", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}

	type SC struct {
		E optBuyType
	}
	sc := SC{E: e}
	b, err = xml.Marshal(sc)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(struct OptBuyType): %s\n", err)
	}
	if string(b) != "<SC><E>BUYTOCLOSE</E></SC>" {
		t.Fatalf("Expected '%s', got '%s'\n", "<SC><E>BUYTOCLOSE</E></SC>", string(b))
	}
}

func TestSellType(t *testing.T) {
	e, err := NewSellType("SELL")
	if err != nil {
		t.Fatalf("Unexpected error creating new SellType from string \"SELL\"\n")
	}
	if !e.Valid() {
		t.Fatalf("SellType unexpectedly invalid\n")
	}
	err = e.FromString("SELLSHORT")
	if err != nil {
		t.Fatalf("Unexpected error on SellType.FromString(\"SELLSHORT\")\n")
	}
	if e.String() != "SELLSHORT" {
		t.Fatalf("SellType.String() expected to be \"SELLSHORT\"\n")
	}

	marshalHelper(t, "SELLSHORT", &e)

	overwritten, err := NewSellType("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new SellType from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("SellType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("SellType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(SellType): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "SELLSHORT", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}

	type SC struct {
		E sellType
	}
	sc := SC{E: e}
	b, err = xml.Marshal(sc)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(struct SellType): %s\n", err)
	}
	if string(b) != "<SC><E>SELLSHORT</E></SC>" {
		t.Fatalf("Expected '%s', got '%s'\n", "<SC><E>SELLSHORT</E></SC>", string(b))
	}
}

func TestLoanPmtFreq(t *testing.T) {
	e, err := NewLoanPmtFreq("WEEKLY")
	if err != nil {
		t.Fatalf("Unexpected error creating new LoanPmtFreq from string \"WEEKLY\"\n")
	}
	if !e.Valid() {
		t.Fatalf("LoanPmtFreq unexpectedly invalid\n")
	}
	err = e.FromString("OTHER")
	if err != nil {
		t.Fatalf("Unexpected error on LoanPmtFreq.FromString(\"OTHER\")\n")
	}
	if e.String() != "OTHER" {
		t.Fatalf("LoanPmtFreq.String() expected to be \"OTHER\"\n")
	}

	marshalHelper(t, "OTHER", &e)

	overwritten, err := NewLoanPmtFreq("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new LoanPmtFreq from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("LoanPmtFreq created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("LoanPmtFreq created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(LoanPmtFreq): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "OTHER", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}

	type SC struct {
		E loanPmtFreq
	}
	sc := SC{E: e}
	b, err = xml.Marshal(sc)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(struct LoanPmtFreq): %s\n", err)
	}
	if string(b) != "<SC><E>OTHER</E></SC>" {
		t.Fatalf("Expected '%s', got '%s'\n", "<SC><E>OTHER</E></SC>", string(b))
	}
}

func TestIncomeType(t *testing.T) {
	e, err := NewIncomeType("CGLONG")
	if err != nil {
		t.Fatalf("Unexpected error creating new IncomeType from string \"CGLONG\"\n")
	}
	if !e.Valid() {
		t.Fatalf("IncomeType unexpectedly invalid\n")
	}
	err = e.FromString("MISC")
	if err != nil {
		t.Fatalf("Unexpected error on IncomeType.FromString(\"MISC\")\n")
	}
	if e.String() != "MISC" {
		t.Fatalf("IncomeType.String() expected to be \"MISC\"\n")
	}

	marshalHelper(t, "MISC", &e)

	overwritten, err := NewIncomeType("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new IncomeType from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("IncomeType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("IncomeType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(IncomeType): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "MISC", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}

	type SC struct {
		E incomeType
	}
	sc := SC{E: e}
	b, err = xml.Marshal(sc)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(struct IncomeType): %s\n", err)
	}
	if string(b) != "<SC><E>MISC</E></SC>" {
		t.Fatalf("Expected '%s', got '%s'\n", "<SC><E>MISC</E></SC>", string(b))
	}
}

func TestSellReason(t *testing.T) {
	e, err := NewSellReason("CALL")
	if err != nil {
		t.Fatalf("Unexpected error creating new SellReason from string \"CALL\"\n")
	}
	if !e.Valid() {
		t.Fatalf("SellReason unexpectedly invalid\n")
	}
	err = e.FromString("MATURITY")
	if err != nil {
		t.Fatalf("Unexpected error on SellReason.FromString(\"MATURITY\")\n")
	}
	if e.String() != "MATURITY" {
		t.Fatalf("SellReason.String() expected to be \"MATURITY\"\n")
	}

	marshalHelper(t, "MATURITY", &e)

	overwritten, err := NewSellReason("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new SellReason from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("SellReason created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("SellReason created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(SellReason): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "MATURITY", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}

	type SC struct {
		E sellReason
	}
	sc := SC{E: e}
	b, err = xml.Marshal(sc)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(struct SellReason): %s\n", err)
	}
	if string(b) != "<SC><E>MATURITY</E></SC>" {
		t.Fatalf("Expected '%s', got '%s'\n", "<SC><E>MATURITY</E></SC>", string(b))
	}
}

func TestOptSellType(t *testing.T) {
	e, err := NewOptSellType("SELLTOCLOSE")
	if err != nil {
		t.Fatalf("Unexpected error creating new OptSellType from string \"SELLTOCLOSE\"\n")
	}
	if !e.Valid() {
		t.Fatalf("OptSellType unexpectedly invalid\n")
	}
	err = e.FromString("SELLTOOPEN")
	if err != nil {
		t.Fatalf("Unexpected error on OptSellType.FromString(\"SELLTOOPEN\")\n")
	}
	if e.String() != "SELLTOOPEN" {
		t.Fatalf("OptSellType.String() expected to be \"SELLTOOPEN\"\n")
	}

	marshalHelper(t, "SELLTOOPEN", &e)

	overwritten, err := NewOptSellType("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new OptSellType from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("OptSellType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("OptSellType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(OptSellType): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "SELLTOOPEN", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}

	type SC struct {
		E optSellType
	}
	sc := SC{E: e}
	b, err = xml.Marshal(sc)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(struct OptSellType): %s\n", err)
	}
	if string(b) != "<SC><E>SELLTOOPEN</E></SC>" {
		t.Fatalf("Expected '%s', got '%s'\n", "<SC><E>SELLTOOPEN</E></SC>", string(b))
	}
}

func TestRelType(t *testing.T) {
	e, err := NewRelType("SPREAD")
	if err != nil {
		t.Fatalf("Unexpected error creating new RelType from string \"SPREAD\"\n")
	}
	if !e.Valid() {
		t.Fatalf("RelType unexpectedly invalid\n")
	}
	err = e.FromString("OTHER")
	if err != nil {
		t.Fatalf("Unexpected error on RelType.FromString(\"OTHER\")\n")
	}
	if e.String() != "OTHER" {
		t.Fatalf("RelType.String() expected to be \"OTHER\"\n")
	}

	marshalHelper(t, "OTHER", &e)

	overwritten, err := NewRelType("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new RelType from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("RelType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("RelType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(RelType): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "OTHER", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}

	type SC struct {
		E relType
	}
	sc := SC{E: e}
	b, err = xml.Marshal(sc)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(struct RelType): %s\n", err)
	}
	if string(b) != "<SC><E>OTHER</E></SC>" {
		t.Fatalf("Expected '%s', got '%s'\n", "<SC><E>OTHER</E></SC>", string(b))
	}
}

func TestCharType(t *testing.T) {
	e, err := NewCharType("ALPHAONLY")
	if err != nil {
		t.Fatalf("Unexpected error creating new CharType from string \"ALPHAONLY\"\n")
	}
	if !e.Valid() {
		t.Fatalf("CharType unexpectedly invalid\n")
	}
	err = e.FromString("ALPHAANDNUMERIC")
	if err != nil {
		t.Fatalf("Unexpected error on CharType.FromString(\"ALPHAANDNUMERIC\")\n")
	}
	if e.String() != "ALPHAANDNUMERIC" {
		t.Fatalf("CharType.String() expected to be \"ALPHAANDNUMERIC\"\n")
	}

	marshalHelper(t, "ALPHAANDNUMERIC", &e)

	overwritten, err := NewCharType("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new CharType from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("CharType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("CharType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(CharType): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "ALPHAANDNUMERIC", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}

	type SC struct {
		E charType
	}
	sc := SC{E: e}
	b, err = xml.Marshal(sc)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(struct CharType): %s\n", err)
	}
	if string(b) != "<SC><E>ALPHAANDNUMERIC</E></SC>" {
		t.Fatalf("Expected '%s', got '%s'\n", "<SC><E>ALPHAANDNUMERIC</E></SC>", string(b))
	}
}

func TestSyncMode(t *testing.T) {
	e, err := NewSyncMode("FULL")
	if err != nil {
		t.Fatalf("Unexpected error creating new SyncMode from string \"FULL\"\n")
	}
	if !e.Valid() {
		t.Fatalf("SyncMode unexpectedly invalid\n")
	}
	err = e.FromString("LITE")
	if err != nil {
		t.Fatalf("Unexpected error on SyncMode.FromString(\"LITE\")\n")
	}
	if e.String() != "LITE" {
		t.Fatalf("SyncMode.String() expected to be \"LITE\"\n")
	}

	marshalHelper(t, "LITE", &e)

	overwritten, err := NewSyncMode("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new SyncMode from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("SyncMode created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("SyncMode created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(SyncMode): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "LITE", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}

	type SC struct {
		E syncMode
	}
	sc := SC{E: e}
	b, err = xml.Marshal(sc)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(struct SyncMode): %s\n", err)
	}
	if string(b) != "<SC><E>LITE</E></SC>" {
		t.Fatalf("Expected '%s', got '%s'\n", "<SC><E>LITE</E></SC>", string(b))
	}
}

func TestOfxSec(t *testing.T) {
	e, err := NewOfxSec("NONE")
	if err != nil {
		t.Fatalf("Unexpected error creating new OfxSec from string \"NONE\"\n")
	}
	if !e.Valid() {
		t.Fatalf("OfxSec unexpectedly invalid\n")
	}
	err = e.FromString("TYPE 1")
	if err != nil {
		t.Fatalf("Unexpected error on OfxSec.FromString(\"TYPE 1\")\n")
	}
	if e.String() != "TYPE 1" {
		t.Fatalf("OfxSec.String() expected to be \"TYPE 1\"\n")
	}

	marshalHelper(t, "TYPE 1", &e)

	overwritten, err := NewOfxSec("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new OfxSec from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("OfxSec created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("OfxSec created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(OfxSec): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "TYPE 1", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}

	type SC struct {
		E ofxSec
	}
	sc := SC{E: e}
	b, err = xml.Marshal(sc)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(struct OfxSec): %s\n", err)
	}
	if string(b) != "<SC><E>TYPE 1</E></SC>" {
		t.Fatalf("Expected '%s', got '%s'\n", "<SC><E>TYPE 1</E></SC>", string(b))
	}
}

func TestDebtType(t *testing.T) {
	e, err := NewDebtType("COUPON")
	if err != nil {
		t.Fatalf("Unexpected error creating new DebtType from string \"COUPON\"\n")
	}
	if !e.Valid() {
		t.Fatalf("DebtType unexpectedly invalid\n")
	}
	err = e.FromString("ZERO")
	if err != nil {
		t.Fatalf("Unexpected error on DebtType.FromString(\"ZERO\")\n")
	}
	if e.String() != "ZERO" {
		t.Fatalf("DebtType.String() expected to be \"ZERO\"\n")
	}

	marshalHelper(t, "ZERO", &e)

	overwritten, err := NewDebtType("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new DebtType from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("DebtType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("DebtType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(DebtType): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "ZERO", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}

	type SC struct {
		E debtType
	}
	sc := SC{E: e}
	b, err = xml.Marshal(sc)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(struct DebtType): %s\n", err)
	}
	if string(b) != "<SC><E>ZERO</E></SC>" {
		t.Fatalf("Expected '%s', got '%s'\n", "<SC><E>ZERO</E></SC>", string(b))
	}
}

func TestDebtClass(t *testing.T) {
	e, err := NewDebtClass("TREASURY")
	if err != nil {
		t.Fatalf("Unexpected error creating new DebtClass from string \"TREASURY\"\n")
	}
	if !e.Valid() {
		t.Fatalf("DebtClass unexpectedly invalid\n")
	}
	err = e.FromString("OTHER")
	if err != nil {
		t.Fatalf("Unexpected error on DebtClass.FromString(\"OTHER\")\n")
	}
	if e.String() != "OTHER" {
		t.Fatalf("DebtClass.String() expected to be \"OTHER\"\n")
	}

	marshalHelper(t, "OTHER", &e)

	overwritten, err := NewDebtClass("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new DebtClass from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("DebtClass created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("DebtClass created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(DebtClass): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "OTHER", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}

	type SC struct {
		E debtClass
	}
	sc := SC{E: e}
	b, err = xml.Marshal(sc)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(struct DebtClass): %s\n", err)
	}
	if string(b) != "<SC><E>OTHER</E></SC>" {
		t.Fatalf("Expected '%s', got '%s'\n", "<SC><E>OTHER</E></SC>", string(b))
	}
}

func TestCouponFreq(t *testing.T) {
	e, err := NewCouponFreq("MONTHLY")
	if err != nil {
		t.Fatalf("Unexpected error creating new CouponFreq from string \"MONTHLY\"\n")
	}
	if !e.Valid() {
		t.Fatalf("CouponFreq unexpectedly invalid\n")
	}
	err = e.FromString("OTHER")
	if err != nil {
		t.Fatalf("Unexpected error on CouponFreq.FromString(\"OTHER\")\n")
	}
	if e.String() != "OTHER" {
		t.Fatalf("CouponFreq.String() expected to be \"OTHER\"\n")
	}

	marshalHelper(t, "OTHER", &e)

	overwritten, err := NewCouponFreq("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new CouponFreq from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("CouponFreq created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("CouponFreq created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(CouponFreq): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "OTHER", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}

	type SC struct {
		E couponFreq
	}
	sc := SC{E: e}
	b, err = xml.Marshal(sc)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(struct CouponFreq): %s\n", err)
	}
	if string(b) != "<SC><E>OTHER</E></SC>" {
		t.Fatalf("Expected '%s', got '%s'\n", "<SC><E>OTHER</E></SC>", string(b))
	}
}

func TestCallType(t *testing.T) {
	e, err := NewCallType("CALL")
	if err != nil {
		t.Fatalf("Unexpected error creating new CallType from string \"CALL\"\n")
	}
	if !e.Valid() {
		t.Fatalf("CallType unexpectedly invalid\n")
	}
	err = e.FromString("MATURITY")
	if err != nil {
		t.Fatalf("Unexpected error on CallType.FromString(\"MATURITY\")\n")
	}
	if e.String() != "MATURITY" {
		t.Fatalf("CallType.String() expected to be \"MATURITY\"\n")
	}

	marshalHelper(t, "MATURITY", &e)

	overwritten, err := NewCallType("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new CallType from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("CallType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("CallType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(CallType): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "MATURITY", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}

	type SC struct {
		E callType
	}
	sc := SC{E: e}
	b, err = xml.Marshal(sc)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(struct CallType): %s\n", err)
	}
	if string(b) != "<SC><E>MATURITY</E></SC>" {
		t.Fatalf("Expected '%s', got '%s'\n", "<SC><E>MATURITY</E></SC>", string(b))
	}
}

func TestAssetClass(t *testing.T) {
	e, err := NewAssetClass("DOMESTICBOND")
	if err != nil {
		t.Fatalf("Unexpected error creating new AssetClass from string \"DOMESTICBOND\"\n")
	}
	if !e.Valid() {
		t.Fatalf("AssetClass unexpectedly invalid\n")
	}
	err = e.FromString("OTHER")
	if err != nil {
		t.Fatalf("Unexpected error on AssetClass.FromString(\"OTHER\")\n")
	}
	if e.String() != "OTHER" {
		t.Fatalf("AssetClass.String() expected to be \"OTHER\"\n")
	}

	marshalHelper(t, "OTHER", &e)

	overwritten, err := NewAssetClass("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new AssetClass from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("AssetClass created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("AssetClass created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(AssetClass): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "OTHER", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}

	type SC struct {
		E assetClass
	}
	sc := SC{E: e}
	b, err = xml.Marshal(sc)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(struct AssetClass): %s\n", err)
	}
	if string(b) != "<SC><E>OTHER</E></SC>" {
		t.Fatalf("Expected '%s', got '%s'\n", "<SC><E>OTHER</E></SC>", string(b))
	}
}

func TestMfType(t *testing.T) {
	e, err := NewMfType("OPENEND")
	if err != nil {
		t.Fatalf("Unexpected error creating new MfType from string \"OPENEND\"\n")
	}
	if !e.Valid() {
		t.Fatalf("MfType unexpectedly invalid\n")
	}
	err = e.FromString("OTHER")
	if err != nil {
		t.Fatalf("Unexpected error on MfType.FromString(\"OTHER\")\n")
	}
	if e.String() != "OTHER" {
		t.Fatalf("MfType.String() expected to be \"OTHER\"\n")
	}

	marshalHelper(t, "OTHER", &e)

	overwritten, err := NewMfType("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new MfType from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("MfType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("MfType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(MfType): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "OTHER", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}

	type SC struct {
		E mfType
	}
	sc := SC{E: e}
	b, err = xml.Marshal(sc)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(struct MfType): %s\n", err)
	}
	if string(b) != "<SC><E>OTHER</E></SC>" {
		t.Fatalf("Expected '%s', got '%s'\n", "<SC><E>OTHER</E></SC>", string(b))
	}
}

func TestOptType(t *testing.T) {
	e, err := NewOptType("PUT")
	if err != nil {
		t.Fatalf("Unexpected error creating new OptType from string \"PUT\"\n")
	}
	if !e.Valid() {
		t.Fatalf("OptType unexpectedly invalid\n")
	}
	err = e.FromString("CALL")
	if err != nil {
		t.Fatalf("Unexpected error on OptType.FromString(\"CALL\")\n")
	}
	if e.String() != "CALL" {
		t.Fatalf("OptType.String() expected to be \"CALL\"\n")
	}

	marshalHelper(t, "CALL", &e)

	overwritten, err := NewOptType("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new OptType from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("OptType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("OptType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(OptType): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "CALL", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}

	type SC struct {
		E optType
	}
	sc := SC{E: e}
	b, err = xml.Marshal(sc)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(struct OptType): %s\n", err)
	}
	if string(b) != "<SC><E>CALL</E></SC>" {
		t.Fatalf("Expected '%s', got '%s'\n", "<SC><E>CALL</E></SC>", string(b))
	}
}

func TestStockType(t *testing.T) {
	e, err := NewStockType("COMMON")
	if err != nil {
		t.Fatalf("Unexpected error creating new StockType from string \"COMMON\"\n")
	}
	if !e.Valid() {
		t.Fatalf("StockType unexpectedly invalid\n")
	}
	err = e.FromString("OTHER")
	if err != nil {
		t.Fatalf("Unexpected error on StockType.FromString(\"OTHER\")\n")
	}
	if e.String() != "OTHER" {
		t.Fatalf("StockType.String() expected to be \"OTHER\"\n")
	}

	marshalHelper(t, "OTHER", &e)

	overwritten, err := NewStockType("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new StockType from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("StockType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("StockType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(StockType): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "OTHER", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}

	type SC struct {
		E stockType
	}
	sc := SC{E: e}
	b, err = xml.Marshal(sc)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(struct StockType): %s\n", err)
	}
	if string(b) != "<SC><E>OTHER</E></SC>" {
		t.Fatalf("Expected '%s', got '%s'\n", "<SC><E>OTHER</E></SC>", string(b))
	}
}

func TestHolderType(t *testing.T) {
	e, err := NewHolderType("INDIVIDUAL")
	if err != nil {
		t.Fatalf("Unexpected error creating new HolderType from string \"INDIVIDUAL\"\n")
	}
	if !e.Valid() {
		t.Fatalf("HolderType unexpectedly invalid\n")
	}
	err = e.FromString("OTHER")
	if err != nil {
		t.Fatalf("Unexpected error on HolderType.FromString(\"OTHER\")\n")
	}
	if e.String() != "OTHER" {
		t.Fatalf("HolderType.String() expected to be \"OTHER\"\n")
	}

	marshalHelper(t, "OTHER", &e)

	overwritten, err := NewHolderType("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new HolderType from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("HolderType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("HolderType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(HolderType): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "OTHER", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}

	type SC struct {
		E holderType
	}
	sc := SC{E: e}
	b, err = xml.Marshal(sc)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(struct HolderType): %s\n", err)
	}
	if string(b) != "<SC><E>OTHER</E></SC>" {
		t.Fatalf("Expected '%s', got '%s'\n", "<SC><E>OTHER</E></SC>", string(b))
	}
}

func TestAcctClassification(t *testing.T) {
	e, err := NewAcctClassification("PERSONAL")
	if err != nil {
		t.Fatalf("Unexpected error creating new AcctClassification from string \"PERSONAL\"\n")
	}
	if !e.Valid() {
		t.Fatalf("AcctClassification unexpectedly invalid\n")
	}
	err = e.FromString("OTHER")
	if err != nil {
		t.Fatalf("Unexpected error on AcctClassification.FromString(\"OTHER\")\n")
	}
	if e.String() != "OTHER" {
		t.Fatalf("AcctClassification.String() expected to be \"OTHER\"\n")
	}

	marshalHelper(t, "OTHER", &e)

	overwritten, err := NewAcctClassification("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new AcctClassification from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("AcctClassification created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("AcctClassification created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(AcctClassification): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "OTHER", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}

	type SC struct {
		E acctClassification
	}
	sc := SC{E: e}
	b, err = xml.Marshal(sc)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(struct AcctClassification): %s\n", err)
	}
	if string(b) != "<SC><E>OTHER</E></SC>" {
		t.Fatalf("Expected '%s', got '%s'\n", "<SC><E>OTHER</E></SC>", string(b))
	}
}

func TestSvcStatus(t *testing.T) {
	e, err := NewSvcStatus("AVAIL")
	if err != nil {
		t.Fatalf("Unexpected error creating new SvcStatus from string \"AVAIL\"\n")
	}
	if !e.Valid() {
		t.Fatalf("SvcStatus unexpectedly invalid\n")
	}
	err = e.FromString("ACTIVE")
	if err != nil {
		t.Fatalf("Unexpected error on SvcStatus.FromString(\"ACTIVE\")\n")
	}
	if e.String() != "ACTIVE" {
		t.Fatalf("SvcStatus.String() expected to be \"ACTIVE\"\n")
	}

	marshalHelper(t, "ACTIVE", &e)

	overwritten, err := NewSvcStatus("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new SvcStatus from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("SvcStatus created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("SvcStatus created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(SvcStatus): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "ACTIVE", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}

	type SC struct {
		E svcStatus
	}
	sc := SC{E: e}
	b, err = xml.Marshal(sc)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(struct SvcStatus): %s\n", err)
	}
	if string(b) != "<SC><E>ACTIVE</E></SC>" {
		t.Fatalf("Expected '%s', got '%s'\n", "<SC><E>ACTIVE</E></SC>", string(b))
	}
}

func TestUsProductType(t *testing.T) {
	e, err := NewUsProductType("401K")
	if err != nil {
		t.Fatalf("Unexpected error creating new UsProductType from string \"401K\"\n")
	}
	if !e.Valid() {
		t.Fatalf("UsProductType unexpectedly invalid\n")
	}
	err = e.FromString("UGMA")
	if err != nil {
		t.Fatalf("Unexpected error on UsProductType.FromString(\"UGMA\")\n")
	}
	if e.String() != "UGMA" {
		t.Fatalf("UsProductType.String() expected to be \"UGMA\"\n")
	}

	marshalHelper(t, "UGMA", &e)

	overwritten, err := NewUsProductType("THISWILLNEVERBEAVALIDENUMSTRING")
	if err == nil {
		t.Fatalf("Expected error creating new UsProductType from string \"THISWILLNEVERBEAVALIDENUMSTRING\"\n")
	}
	if overwritten.Valid() {
		t.Fatalf("UsProductType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not be valid\n")
	}
	if !strings.Contains(strings.ToLower(overwritten.String()), "invalid") {
		t.Fatalf("UsProductType created with string \"THISWILLNEVERBEAVALIDENUMSTRING\" should not return valid string from String()\n")
	}

	b, err := xml.Marshal(&overwritten)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(UsProductType): %s\n", err)
	}
	if string(b) != "" {
		t.Fatalf("Expected empty string, got '%s'\n", string(b))
	}

	unmarshalHelper(t, "UGMA", &e, &overwritten)

	err = xml.Unmarshal([]byte("<GARBAGE><!LALDK>"), &overwritten)
	if err == nil {
		t.Fatalf("Expected error unmarshalling garbage value\n")
	}

	type SC struct {
		E usProductType
	}
	sc := SC{E: e}
	b, err = xml.Marshal(sc)
	if err != nil {
		t.Fatalf("Unexpected error on xml.Marshal(struct UsProductType): %s\n", err)
	}
	if string(b) != "<SC><E>UGMA</E></SC>" {
		t.Fatalf("Expected '%s', got '%s'\n", "<SC><E>UGMA</E></SC>", string(b))
	}
}
